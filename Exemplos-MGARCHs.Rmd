---
output:
    html_document:
        fig_caption: true
        number_sections: true
        theme: readable
--- 
---
title: "Exemplos para processos GARCH multivariados "
author: "Kim Samejima Lopes"
date: "11-12-2014"
---  
  
[//]: #         includes:
[//]: #             in_header: mystyles.sty  
[//]: #  theme ("default", "cerulean", "journal", "flatly", "readable", "spacelab", "united", or "cosmo")

```{r,echo=F,warning=FALSE,message=FALSE,include=FALSE}
library(rugarch)
library(ccgarch)
library(rmgarch)
library(gogarch)
library(knitcitations)
cite_options(cite.style = "numeric")
options(xtable.comment = FALSE)
```



Este texto trata da construção de exemplos de modelos GARCH multivariados. Para tanto, considere os modelos a seguir:  

* VEC e BEKK  
* CCC-GARCH e DCC-GARCH  
* F-GARCH, O-GARCH e GO-GARCH  
* ICA-GARCH e GICA-GARCH   


As próximas sessões apresentarão exemplos de tais modelos utilizando as bibliotecas `ccgarch,rmgarch e gogarch` do **R**.    

<font color="red">  

# VEC e BEKK  

</font>  

# CCC-GARCH e DCC-GARCH    
## CCC-GARCH    

Modelos CCC-GARCH são da forma:  

(@eqcccgarch) $$
\label{eq:cccgarch}
\textbf{H}_t = \textbf{D}_t \times \textbf{R}  \times \textbf{D}_t \\
\textbf{D}_t= \left[diag\{h_{ii,t}^{1/2}\}\right],i=1,\dots,n  
$$

$h_{ii,t}$ é um modelo GARCH univariado qualquer e $\textbf{R}= \left[\rho_{i,j}\right],i,j=1,\dots,n$ e $\rho_{i,i}=1,i=1,\dots,n$ é uma matriz simétrica, positiva definida.   
Teremos que $\textbf{H}_t$ será positiva definida se e só se todas as n variâncias condicionais forem positivas e $\textbf{H}_t\ge 0$.
Em particular um CCC-GARCH(1,1) seria da forma dada em  (@eqcccgarch), com $h_{ii,t},i=1,\dots,n$ definidos por   
$$
h_{ii,t}=w_i+\alpha_i\epsilon^2_{i,t-1}+\beta_i h_{ii,t-1},i=1\dots,n
$$  
Ou seja, cada $h_{ii,t}$ é dado por um GARCH(1,1).

### Exemplo Simulado   
Utilizando o pacote `ccgarch`, simularemos um modelo CCC-GARCH(1,1) bivariado definido por:
$$
\textbf{R}=\left(\begin{array}{cc} 1 & 0.8 \\ 0.8 & 1\end{array}\right) \\
h_{11,t}= 0.05 + 0.5 \epsilon^2_{1,t-1}+ 0.2 h_{11,t-1} \\
h_{22,t}= 0.02 + 0.7 \epsilon^2_{2,t-1}+ 0.1 h_{22,t-1} 
$$  

```{r sim1}
### EXEMPLOS USANDO O PACOTE 'ccgarch'

# 'nobs'  a number of observations to be simulated (T)
# 'a'     a vector of constants in the GARCH equation (N×1)
# 'A'     an ARCH parameter matrix in the GARCH equation. A can be a diagonal matrix for the original CCC-GARCH model 
#         or a full matrix for the extended model (N×N)
# 'B'     a GARCH parameter matrix in the GARCH equation. B can be a diagonal matrix for the original CCC-GARCH model 
#         or a full matrix for the extended model (N×N)
# 'R'     a constant conditional correlation matrix (N×N)
# 'd.f'   the degrees of freedom parameter for the t-distribution
# 'model' "diagonal" for the diagonal model and "extended" for the extended model

a1=c(0.05,0.02)
A1=matrix(c(0.5,0,0,0.7),ncol=2)
B1=matrix(c(0.2,0,0,0.1),ncol=2)
R1=matrix(c(1,-0.3,0.8,1),ncol=2)
H1<-eccc.sim(nobs=1000, a1, A1, B1, R1, d.f=5, model="diagonal")

#'h'      a matrix of the simulated conditional variances (T × N )
#'eps'    a matrix of the simulated time series with (E)CCC-GARCH process (T × N )
```

```{r fig1_sim1}
plot.ts(H1$eps, main = "Processos simulados")
```

```{r fig2_sim1}
plot.ts(H1$h, main="Volatilidade observada nos processos simulados")
```

Para o processo simulado, vamos estimar os parâmetros utilizando o mesmo pacote, com a função `eccc.estimation`.
Temos duas séries simuladas, e suporemos então que elas seguem um CCC-GARCH(1,1) e são regidas pelo processo:  
$$
\textbf{h}_t=\left(
\begin{array}{c}
 h_{11,t} \\ h_{22,t}
\end{array}
\right)=\textbf{w}+\textbf{A}\textbf{$\epsilon$}_{t-1}\textbf{$\epsilon$}_{t-1}^T+\textbf{B}\textbf{h}_{t-1}=\\
=
\left(\begin{array}{c} w_{1} \\ w_{2} \end{array} \right) + 
\left(\begin{array}{cc} \alpha_{1} & 0 \\ 0 & \alpha_{2} \end{array} \right) 
\left(\begin{array}{c} \epsilon^2_{1,t-1} \\ \epsilon^2_{2,t-1} \end{array} \right) + 
\left(\begin{array}{cc} \beta_{1}  & 0 \\ 0 & \beta_{2} \end{array} \right) 
\left(\begin{array}{c} h_{11,t-1} \\ h_{22,t-1} \end{array} \right)
$$

Para estimar o processo, é necessário sugerir os 'chutes' iniciais para o algoritmo de otimização. Façamos então:  

$$
\textbf{w}_0=\textbf{1}_2 \\
\textbf{A}_0=\textbf{I}_2 \\
\textbf{B}_0=\textbf{I}_2 \\
\textbf{R}_0=\textbf{I}_2 \\
$$

*OBS:* Se Considerarmos o chute inicial para $\textbf{w}_0=\textbf{0}_2$ ou $\textbf{w}_0=\underset{\sim}{\mu}$ o processo nao converge para um valor próximo ao valor correto dos parâmetros.

```{r est1_code}
w0=c(1,1)
A0=diag(2)
B0=diag(2)
R0=diag(2)
fit<-eccc.estimation(a=w0,A=A0,B=B0,R=R0,model="diagonal",dvar=H1$eps)
fit$opt$convergence
# $convergence == 0 ## Means convergence criteria has reached
```

Os resultados da estimação foram:  

```{r est1_results}
fit$para.mat
fit$out
```

É possivel ainda estimar os resultados do processo CCC-GARCH simulado na seção anterior utilizando o pacote `rmgarch`, considerando que o modelo CCC-GARCH é um caso especial do DCC-GARCH, quando a matriz $R$ é fixa para todo *t*.

```{r}
spec1 = ugarchspec(distribution = "norm")
mspec = multispec(c(spec1,spec1))
fitspec=dccspec(mspec,VAR=TRUE,lag=1,dccOrder=c(1,1),model="DCC",distribution="mvnorm")
fit2=dccfit(fitspec,H1$eps)

```


## DCC-GARCH   

Modelos DCC-GARCH são uma generalização do caso CCC-GARCH, isto é, temos a matris **R** não necessáriamente fixa, ou seja, ela varia no tempo:  

(@eqdccgarch) $$
\label{eq:dccgarch}
\textbf{H}_t = \textbf{D}_t \times \textbf{R}_t  \times \textbf{D}_t \\
$$

$\textbf{D}_t$ é definida como em (@eqcccgarch) e $\textbf{R}_t$ tem expressão específica. Tse e Tsui(2002) sugerem $\textbf{R}_t$ definida por $\textbf{R_t}=(1-\theta_1-\theta_2)\textbf{R}+\theta_1\Psi_{t-1}+\theta_2\textbf{R}_{t-1}$ em que $\textbf{R}= \left[\rho_{i,j}\right], i,j = 1,\dots,n$ e $\rho_{i,i}=1,i=1,\dots,n$ é uma matriz simétrica, positiva definida e $\Psi_{t-1}$ uma matriz de correlações de $\epsilon_\tau$ definida convenientemente.   
Já Engle(2002) propõe $\textbf{R}_t$ como $\left[diag\{\textbf{Q}_t\}\right]^{1/2}\times \textbf{Q}_t \times \left[diag\{\textbf{Q}_t\}\right]^{1/2}$, com $\textbf{Q}_t$ não negativa definida, de ordem $n\times n$ definida de forma semelhante a $\textbf{R}_t$.  


### Exemplo Simulado   
Para simular o processo DCC-GARCH, consideraremos os pacotes `ccgarch` e o pacote `rmgarch`, para que possamos comparar suas performances.  

<font color="red">   

## DCCe-GARCH (Engle)   

# F-GARCH, O-GARCH e GO-GARCH  
Pacote `gogarch` e pacote `rmgarch`  

# ICA-GARCH e GICA-GARCH   
Pacote `rmgarch`  

</font>

